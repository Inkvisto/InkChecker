import {
  BlockEvent,
  Finding,
  HandleTransaction,
  TransactionEvent,
  FindingSeverity,
  FindingType,
  LogDescription,
  ethers,
  getEthersProvider
} from "forta-agent";

import config from './agent-config.json';
import timelock_abi from './timelock_abi.json'
import { contract_lost_selfadministration_finding, executor_got_admin_role_finding, executor_got_proposer_role_finding, main_exploit_finding, proposal_lifecycle_violation_finding, role_renounced_finding, role_revoked_finding, untrusted_executor_finding, zero_delay_finding } from "./findings";


const {
  developerAbbreviation: developerAbbrev,
  protocolName,
  protocolAbbrev,
  contracts,
} = config;



const extract_argument = async (event: LogDescription, argument: string) => {
  return event.args[argument];
}

const check_new_min_delay_is_zero = async (event: LogDescription): Promise<boolean> => {
  return await extract_argument(event, "newDuration") == 0
};


export const timelockEvents = [
  "MinDelayChange(uint256,uin256)",
  "CallScheduled(bytes32,uint256,address,uint256,bytes,bytes32,uint256)",
  "Cancelled(bytes32)",
  "CallExecuted(bytes32,uint256,address,uint256,bytes)"
];


const TIMELOCK_ADMIN_ROLE = ethers.utils.solidityKeccak256(['string'], ['TIMELOCK_ADMIN_ROLE']);
const PROPOSER_ROLE = ethers.utils.solidityKeccak256(['string'], ['PROPOSER_ROLE']);
const EXECUTOR_ROLE = ethers.utils.solidityKeccak256(['string'], ['EXECUTOR_ROLE']);
const CANCELLER_ROLE = ethers.utils.solidityKeccak256(['string'], ['CANCELLER_ROLE']);


const provider = getEthersProvider();

// get list of addresses to watch
const contractList = Object.values(contracts);
if (contractList.length === 0) {
  throw new Error('Must supply at least one address to watch');
}



const detectMainExploit = async (txEvent: TransactionEvent) => {
  const MinDelayEvents = txEvent.filterLog('event MinDelayChange(uint256 oldDuration, uint256 newDuration)');
  const SheduledAndExecutedEvents = txEvent.filterLog(['event CallScheduled(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data, bytes32 predecessor, uint256 delay)', 'event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data)']);

  const findings: Finding[] = [];
  const danger_proposals_id: string[] = [];

  for (let event of MinDelayEvents) {
    if (await check_new_min_delay_is_zero(event)) {
      findings.push(zero_delay_finding(event.address, txEvent.from, txEvent.transaction.hash, await extract_argument(event, 'oldDuration')));
    }
  }

  for (let event of SheduledAndExecutedEvents) {

    const proposal_id: string = await extract_argument(event, 'id');

    if (event.name === 'CallExecuted') {
      danger_proposals_id.push(proposal_id)
    } else if (event.name === 'CallSheduled') {
      if (danger_proposals_id.includes(proposal_id)) {
        for (let el of findings) {
          if (el.alertId === 'TIMELOCK-ZERO-DELAY') {
            findings.push(main_exploit_finding(event.address, txEvent.from, txEvent.hash, proposal_id));
          }
        }
      }
    } else {
      findings.push(proposal_lifecycle_violation_finding(event.address, txEvent.from, txEvent.hash, proposal_id))
    }
  }

  return findings;
}

const detectNewRoleForExecutor = async (txEvent: TransactionEvent) => {




  const findings: Finding[] = [];
  const RoleGrantedEvents = txEvent.filterLog('event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)');



  for (let event of RoleGrantedEvents) {

    const role = await extract_argument(event, 'role');
    const account = await extract_argument(event, 'account');


    if ("0x" + role === EXECUTOR_ROLE) return findings;

    const timelock = new ethers.Contract(event.address, timelock_abi, provider);





    if (timelock.hasRole(EXECUTOR_ROLE, await extract_argument(event, 'account'))) {
      if ("0x" + role === PROPOSER_ROLE) {
        findings.push(executor_got_proposer_role_finding(event.address, account, txEvent.from, txEvent.hash));
      } else if ("0x" + role === TIMELOCK_ADMIN_ROLE) {
        findings.push(executor_got_admin_role_finding(event.address, account, txEvent.from, txEvent.hash));
      }

    }

  }

  return findings;
}

const detect_untrusted_executor = async (txEvent: TransactionEvent) => {


  const findings:Finding[] = [];

 
  const iface = new ethers.utils.Interface(timelock_abi.filter((e) => e.type === 'event'));
  const events = iface.format(ethers.utils.FormatTypes.full);
 
  for( let event of txEvent.filterLog(events)) {

    const account = await extract_argument(event, 'account');


    const timelock = new ethers.Contract(event.address, timelock_abi, provider);


    const has_exec = timelock.hasRole(EXECUTOR_ROLE, account);
    const has_prop = timelock.hasRole(PROPOSER_ROLE, account);

    if(!has_exec) return findings;
    

    if(has_exec && !has_prop) findings.push(untrusted_executor_finding(event.address,txEvent.from));
    
  }

  return findings;
}

const detect_revoke_role = async (txEvent:TransactionEvent) => {

  const findings:Finding[] = [];
  const RoleRevokedEvents = txEvent.filterLog('event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)');

  for(let event of RoleRevokedEvents){

    const role = await extract_argument(event, 'role');
    const account = await extract_argument(event, 'account');


    if(txEvent.transaction.to === account && role === TIMELOCK_ADMIN_ROLE){
      findings.push(contract_lost_selfadministration_finding(account, txEvent.from,txEvent.hash))
    } else if(txEvent.from === account){
      findings.push(role_renounced_finding(txEvent.to,txEvent.from,role,txEvent.hash))
    } else {
      findings.push(role_revoked_finding(txEvent.to,account, txEvent.from,role,txEvent.hash))
    }
  }

return findings;
}


const handleTransaction: HandleTransaction = async (
  txEvent: TransactionEvent
) => {
  const findings: Finding[] = [];



  
 
  //await detectMainExploit(txEvent);
  //await detectNewRoleForExecutor(txEvent);
  await detect_untrusted_executor(txEvent);
  await detect_revoke_role(txEvent);

  const txAddrs = Object.keys(txEvent.addresses).map((address) => address.toLowerCase());

  // check if an address in the watchlist was the initiator of the transaction
  contractList.forEach((contract, index) => {
    if (txAddrs.includes(contract.address.toLowerCase())) {
      const params = Object.values(contracts)[index];
      // eslint-disable-next-line max-len
      //findings.push(createAlert(protocolName, contract.address, params.name, protocolAbbrev, params.watch.type, params.watch.severity));
    }
  });

  return findings;
};

// const initialize: Initialize = async () => {
//   // do some initialization on startup e.g. fetch data
// }

// const handleBlock: HandleBlock = async (blockEvent: BlockEvent) => {
//   const findings: Finding[] = [];
//   // detect some block condition
//   return findings;
// }

// const handleAlert: HandleAlert = async (alertEvent: AlertEvent) => {
//   const findings: Finding[] = [];
//   // detect some alert condition
//   return findings;
// }

export default {
  // initialize,
  handleTransaction,
  // handleBlock,
  // handleAlert
};
