import {
  BlockEvent,
  Finding,
  HandleTransaction,
  TransactionEvent,
  FindingSeverity,
  FindingType,
} from "forta-agent";

import config from './agent-config.json';

const {
  developerAbbreviation: developerAbbrev,
  protocolName,
  protocolAbbrev,
  contracts,
} = config;


export const timelockEvents = [
  "MinDelayChange(uint256,uin256)",
  "CallScheduled(bytes32,uint256,address,uint256,bytes,bytes32,uint256)",
  "Cancelled(bytes32)",
  "CallExecuted(bytes32,uint256,address,uint256,bytes)"
];


// get list of addresses to watch
const contractList = Object.values(contracts);
if (contractList.length === 0) {
  throw new Error('Must supply at least one address to watch');
}



const detectMainExploit = async( txEvent: TransactionEvent) => {
const event = txEvent.filterLog('event MinDelayChange(uint256 oldDuration, uint256 newDuration)');
const findings: Finding[] = [];
  const danger_proposals_id = [];

  console.log(event);
  


}



const handleTransaction: HandleTransaction = async (
  txEvent: TransactionEvent
) => {
  const findings: Finding[] = [];
 /*

  const timeLockEvents = timelockEvents.filter((value) => {
    const event = txEvent.filterEvent(value);
    return event.length === 0 ? false : true;
  });*/

// if (!timeLockEvents.length) return findings;

  await detectMainExploit(txEvent);

  const txAddrs = Object.keys(txEvent.addresses).map((address) => address.toLowerCase());

  // check if an address in the watchlist was the initiator of the transaction
  contractList.forEach((contract, index) => {
    if (txAddrs.includes(contract.address.toLowerCase())) {
      const params = Object.values(contracts)[index];
      // eslint-disable-next-line max-len
      //findings.push(createAlert(protocolName, contract.address, params.name, protocolAbbrev, params.watch.type, params.watch.severity));
    }
  });

  return findings;
};

// const initialize: Initialize = async () => {
//   // do some initialization on startup e.g. fetch data
// }

// const handleBlock: HandleBlock = async (blockEvent: BlockEvent) => {
//   const findings: Finding[] = [];
//   // detect some block condition
//   return findings;
// }

// const handleAlert: HandleAlert = async (alertEvent: AlertEvent) => {
//   const findings: Finding[] = [];
//   // detect some alert condition
//   return findings;
// }

export default {
  // initialize,
  handleTransaction,
  // handleBlock,
  // handleAlert
};
