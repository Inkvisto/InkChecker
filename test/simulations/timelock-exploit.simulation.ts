
/*
import { expect } from 'chai';
import { ethers } from "hardhat";
import { SignerWithAddress } from "@nomiclabs/hardhat-ethers/signers";
import { CallReceiverMock, Implementation2, Ink_Governor,IVotes, TimelockController } from '../../typechain-types';
import { loadFixture, time } from '@nomicfoundation/hardhat-network-helpers'
import { Address } from 'hardhat-deploy/types';

import { MINDELAY, random_salt, ZERO_ADDRESS, ZERO_BYTES32 } from '../utils/constants';


const genOperation = (target: string, value: string, data: string, predecessor: string, salt: string) => {

    const id = ethers.utils.keccak256(ethers.utils.defaultAbiCoder.encode([
      'address',
      'uint256',
      'bytes',
      'uint256',
      'bytes32',
    ], [
      target,
      value,
      data,
      predecessor,
      salt,
    ]));
    return { id, target, value, data, predecessor, salt };
  }
  
  const genOperationBatch = (targets: string[], values: string[], payloads: string[], predecessor: string, salt: string) => {
    const id = ethers.utils.keccak256(ethers.utils.defaultAbiCoder.encode([
      'address[]',
      'uint256[]',
      'bytes[]',
      'uint256',
      'bytes32',
    ], [
      targets,
      values,
      payloads,
      predecessor,
      salt,
    ]));
    return { id, targets, values, payloads, predecessor, salt };
  }



describe("timelock_controller agent", () => {


    const MINDELAY = 20;

    const TIMELOCK_ADMIN_ROLE = ethers.utils.solidityKeccak256(['string'], ['TIMELOCK_ADMIN_ROLE']);
    const PROPOSER_ROLE = ethers.utils.solidityKeccak256(['string'], ['PROPOSER_ROLE']);
    const EXECUTOR_ROLE = ethers.utils.solidityKeccak256(['string'], ['EXECUTOR_ROLE']);
    const CANCELLER_ROLE = ethers.utils.solidityKeccak256(['string'], ['CANCELLER_ROLE']);


    describe("handleTransaction", () => {

        const deployTimelockControllerFixture = async () => {
            const [admin, proposer, canceller, executor, other] = await ethers.getSigners()

            const TimeLock = await ethers.getContractFactory("TimelockController");

            const timelock = await TimeLock.deploy(MINDELAY, [proposer.address], [executor.address], admin.address)
            await timelock.deployed()

            expect(await timelock.hasRole(CANCELLER_ROLE, proposer.address)).to.be.equal(true);
            await timelock.connect(admin).revokeRole(CANCELLER_ROLE, proposer.address);
            await timelock.connect(admin).grantRole(CANCELLER_ROLE, canceller.address);

            return { timelock, admin, proposer, executor };

        }
        it('return_zero_delay', async () => {
            const { timelock, admin, proposer, executor } = await loadFixture(deployTimelockControllerFixture);
            it('timelock scheduled maintenance', async () => {
                const newDelay = 0;
                let id: string;
                let target: Address;
                let value: string;
                let data: string;
                let predecessor: string;
                let salt: string;
          
                ({ id, target, value, data, predecessor, salt } = genOperation(
                  timelock.address,
                  '0',
                  timelock.interface.encodeFunctionData('updateDelay', [newDelay.toString()]),
                  ZERO_BYTES32,
                  '0xf8e775b2c5f4d66fb5c7fa800f35ef518c262b6014b3c0aee6ea21bff157f108',
                ));
          
                await timelock.connect(proposer).schedule(
                  target,
                  value,
                  data,
                  predecessor,
                  salt,
                  MINDELAY,
                );
                await time.increase(MINDELAY);
                const tx = await (await timelock.connect(executor).execute(
                  target,
                  value,
                  data,
                  predecessor,
                  salt
                )).wait();
                expect(tx).to.emit(timelock, "MinDelayChange").withArgs({ newDuration: newDelay.toString(), oldDuration: MINDELAY });
          
                expect(await timelock.getMinDelay()).to.be.equal(newDelay);
              });

        })

    })
})
*/